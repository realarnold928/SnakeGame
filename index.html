<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>贪吃蛇 Snake Game</title>
  <style>
    :root {
      --bg: radial-gradient(1200px 800px at 10% 10%, #0e1220, #060810 60%, #04060c);
      --panel: rgba(255, 255, 255, 0.06);
      --panel-border: rgba(255, 255, 255, 0.12);
      --text: #e8eefc;
      --subtext: #a9b3c5;
      --accent: #66e3a3;
      --accent-2: #62b0ff;
      --danger: #ff6b6b;
      --shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.06);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "PingFang SC", "Microsoft Yahei", "Hiragino Sans GB", Arial, "Noto Sans", sans-serif;
      background: var(--bg);
      display: grid; place-items: center;
    }
    .app {
      width: min(92vw, 900px);
      display: grid; gap: 16px; align-items: start;
      grid-template-columns: 1fr;
    }
    @media (min-width: 860px) {
      .app { grid-template-columns: 1.15fr .85fr; gap: 20px; }
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 16px;
      backdrop-filter: blur(8px);
    }
    .header { display:flex; align-items: center; justify-content: space-between; gap: 12px; }
    .title { font-weight: 700; letter-spacing: .5px; }
    .meta { color: var(--subtext); font-size: 13px; }

    .board-wrap { position: relative; aspect-ratio: 1/1; }
    canvas { width: 100%; height: 100%; display: block; border-radius: 14px; border: 1px solid var(--panel-border); box-shadow: var(--shadow); background: linear-gradient(180deg, #0b1326 0%, #0a1221 100%); }

    .hud { display:grid; grid-template-columns: repeat(3,1fr); gap: 10px; margin-top: 12px; }
    .stat { background: var(--panel); border: 1px solid var(--panel-border); border-radius: 12px; padding: 10px 12px; display:flex; align-items: center; justify-content: space-between; gap:10px; }
    .stat .label { color: var(--subtext); font-size: 12px; }
    .stat .value { font-weight: 700; }

    .controls { display:flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; }
    button, select {
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02));
      color: var(--text);
      border: 1px solid var(--panel-border);
      padding: 10px 14px; border-radius: 12px; cursor: pointer; font-weight: 600;
      transition: transform .06s ease, background .2s ease, border-color .2s ease;
    }
    button:hover { transform: translateY(-1px); border-color: #7da7ff55; }
    .primary { background: linear-gradient(180deg, #3bd1a5, #1fbf98); color: #06221a; border: none; }
    .danger { background: linear-gradient(180deg, #ff8787, #ff6b6b); color: #220808; border: none; }

    .legend { font-size: 13px; color: var(--subtext); line-height: 1.6; }
    .kbd { display:inline-grid; place-items:center; min-width: 24px; padding: 2px 6px; border-radius: 6px; background: rgba(255,255,255,.08); border: 1px solid var(--panel-border); font-weight: 600; color: var(--text); }

    .overlay { position:absolute; inset:0; display:grid; place-items:center; pointer-events:none; }
    .badge { pointer-events:auto; background: rgba(0,0,0,.45); border:1px solid var(--panel-border); padding:10px 14px; border-radius: 12px; font-weight:700; color: var(--text); box-shadow: var(--shadow); }

    .touch-hints { display:none; grid-template-columns: repeat(3,1fr); gap:8px; margin-top: 10px; }
    .touch-hints .hint { text-align:center; background: var(--panel); border: 1px solid var(--panel-border); border-radius: 10px; padding: 8px; color: var(--subtext); }

    @media (max-width: 720px) {
      .hud { grid-template-columns: repeat(2, 1fr); }
      .touch-hints { display:grid; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="card">
      <div class="header">
        <div>
          <div class="title">贪吃蛇</div>
          <div class="meta">方向键/WASD 控制 · 支持触摸滑动 · 可调速度</div>
        </div>
        <div class="legend">暂停 <span class="kbd">P</span> / 重新开始 <span class="kbd">R</span></div>
      </div>

      <div class="board-wrap">
        <canvas id="board" aria-label="Snake game board" role="img"></canvas>
        <div class="overlay" id="overlay"><div class="badge" id="badge">按 空格 开始</div></div>
      </div>

      <div class="hud">
        <div class="stat"><span class="label">分数</span><span class="value" id="score">0</span></div>
        <div class="stat"><span class="label">最高分</span><span class="value" id="hiscore">0</span></div>
        <div class="stat"><span class="label">速度</span>
          <select id="speed">
            <option value="170">慢速</option>
            <option value="120" selected>标准</option>
            <option value="90">快速</option>
            <option value="65">狂飙</option>
          </select>
        </div>
      </div>

      <div class="controls">
        <button class="primary" id="btn-toggle">开始</button>
        <button class="danger" id="btn-restart">重开</button>
      </div>

      <div class="touch-hints">
        <div class="hint">向上：上滑</div>
        <div class="hint">暂停：点按画布</div>
        <div class="hint">向下：下滑</div>
        <div class="hint">向左：左滑</div>
        <div class="hint">吃到食物+1分</div>
        <div class="hint">向右：右滑</div>
      </div>
    </div>

    <div class="card">
      <div class="title" style="margin-bottom:8px">玩法说明</div>
      <div class="legend">
        - 使用方向键或 WASD 控制蛇的移动；不能直接反向折返。<br/>
        - 吃到食物得分，碰到墙壁或自身则游戏结束。<br/>
        - 空格或按钮进行开始/暂停，R 键快速重开；可在右侧选择速度。<br/>
        - 触屏设备：在画布上滑动方向即可控制；轻点画布进行暂停/继续。
      </div>
    </div>
  </div>

  <script>
    // 基础配置
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const badge = document.getElementById('badge');
    const scoreEl = document.getElementById('score');
    const hiscoreEl = document.getElementById('hiscore');
    const speedSel = document.getElementById('speed');
    const btnToggle = document.getElementById('btn-toggle');
    const btnRestart = document.getElementById('btn-restart');

    const GRID = 24; // 网格大小（列、行）
    let cellSize = 24; // 像素尺寸基于设备宽度自适应

    // DPR 处理，保证清晰
    function fitCanvas() {
      const wrap = canvas.parentElement.getBoundingClientRect();
      const size = Math.min(wrap.width, wrap.height || wrap.width);
      const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
      cellSize = Math.floor(size / GRID);
      const cssSize = cellSize * GRID;
      canvas.style.width = cssSize + 'px';
      canvas.style.height = cssSize + 'px';
      canvas.width = Math.floor(cssSize * dpr);
      canvas.height = Math.floor(cssSize * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', fitCanvas);

    // 游戏状态
    const DIR = { ArrowUp:[0,-1], ArrowDown:[0,1], ArrowLeft:[-1,0], ArrowRight:[1,0] };
    const WASD = { w:'ArrowUp', a:'ArrowLeft', s:'ArrowDown', d:'ArrowRight', W:'ArrowUp', A:'ArrowLeft', S:'ArrowDown', D:'ArrowRight' };
    let running = false;
    let dead = false;
    let score = 0;
    const HISCORE_KEY = 'snake_hiscore_v1';
    let hiscore = Number(localStorage.getItem(HISCORE_KEY) || 0);
    hiscoreEl.textContent = hiscore;

    // 初始化蛇
    let snake, dir, nextDir, food;
    function initGame() {
      const cx = Math.floor(GRID/2);
      const cy = Math.floor(GRID/2);
      snake = [ {x:cx, y:cy}, {x:cx-1, y:cy}, {x:cx-2, y:cy} ];
      dir = {x:1,y:0};
      nextDir = {x:1,y:0};
      score = 0; scoreEl.textContent = score;
      dead = false;
      placeFood();
      updateBadge('按 空格 开始');
      draw();
    }

    function placeFood() {
      while (true) {
        const fx = Math.floor(Math.random()*GRID);
        const fy = Math.floor(Math.random()*GRID);
        if (!snake.some(s => s.x===fx && s.y===fy)) { food = {x:fx,y:fy}; return; }
      }
    }

    function setDirection(key) {
      const mapped = WASD[key] || key;
      const v = DIR[mapped];
      if (!v) return;
      // 禁止直接反向
      if (v[0] === -dir.x && v[1] === -dir.y) return;
      nextDir = {x:v[0], y:v[1]};
    }

    // 触摸滑动
    let touchStart = null;
    canvas.addEventListener('touchstart', (e)=>{
      if (e.touches.length) touchStart = {x:e.touches[0].clientX, y:e.touches[0].clientY};
    }, {passive:true});
    canvas.addEventListener('touchend', (e)=>{
      if (!touchStart) return;
      const t = e.changedTouches[0];
      const dx = t.clientX - touchStart.x;
      const dy = t.clientY - touchStart.y;
      const ax = Math.abs(dx), ay = Math.abs(dy);
      const TH = 22; // 最小滑动
      if (ax < TH && ay < TH) { toggleRun(); return; }
      if (ax > ay) setDirection(dx>0? 'ArrowRight':'ArrowLeft');
      else setDirection(dy>0? 'ArrowDown':'ArrowUp');
      touchStart = null;
    }, {passive:true});

    // 键盘
    window.addEventListener('keydown', (e)=>{
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
      if (e.key === ' ' || e.code === 'Space') { toggleRun(); }
      else if (e.key === 'p' || e.key === 'P') { toggleRun(); }
      else if (e.key === 'r' || e.key === 'R') { restart(); }
      else setDirection(e.key);
    });

    // 控件
    btnToggle.addEventListener('click', toggleRun);
    btnRestart.addEventListener('click', restart);
    speedSel.addEventListener('change', ()=>{ if (!running) draw(); });

    function updateBadge(text, show = true) {
      badge.textContent = text;
      overlay.style.opacity = show? '1':'0';
    }

    // 游戏循环（基于时间步长）
    let last = 0, acc = 0;
    function loop(ts) {
      if (!running) return; // 暂停时停止 rAF
      if (!last) last = ts;
      const dt = ts - last; last = ts;
      const step = Number(speedSel.value); // 每步毫秒
      acc += dt;
      while (acc >= step) {
        tick();
        acc -= step;
        if (dead) { running = false; btnToggle.textContent = '开始'; updateBadge('游戏结束 · 按 R 重开'); return; }
      }
      draw();
      requestAnimationFrame(loop);
    }

    function tick() {
      dir = nextDir;
      const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
      // 撞墙
      if (head.x < 0 || head.y < 0 || head.x >= GRID || head.y >= GRID) { dead = true; return; }
      // 撞自己
      if (snake.some(s => s.x===head.x && s.y===head.y)) { dead = true; return; }
      snake.unshift(head);
      // 吃食物
      if (head.x === food.x && head.y === food.y) {
        score++; scoreEl.textContent = score;
        if (score > hiscore) { hiscore = score; hiscoreEl.textContent = hiscore; localStorage.setItem(HISCORE_KEY, String(hiscore)); }
        placeFood();
      } else {
        snake.pop();
      }
    }

    // 绘制
    function drawGrid() {
      const s = cellSize; ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,.04)';
      ctx.lineWidth = 1; ctx.beginPath();
      for (let i=1;i<GRID;i++) { ctx.moveTo(i*s+.5, 0); ctx.lineTo(i*s+.5, GRID*s); ctx.moveTo(0, i*s+.5); ctx.lineTo(GRID*s, i*s+.5); }
      ctx.stroke(); ctx.restore();
    }

    function drawSnake() {
      const s = cellSize; const n = snake.length;
      for (let i=n-1;i>=0;i--) {
        const p = snake[i];
        const t = i/(n-1 || 1);
        const col = `hsl(${180 + t*120}, 85%, ${40 + t*12}%)`;
        roundedRect(p.x*s+2, p.y*s+2, s-4, s-4, 6, col);
      }
      // 画眼睛
      const h = snake[0];
      const cx = h.x*s + s/2, cy = h.y*s + s/2;
      const ex = cx + (dir.x||0)*s*0.18 - (dir.y||0)*s*0.12;
      const ey = cy + (dir.y||0)*s*0.18 - (dir.x||0)*s*0.12;
      circle(ex, ey, s*0.11, '#0a0f18');
    }

    function drawFood() {
      const s = cellSize; const x = food.x*s, y = food.y*s;
      const g = ctx.createLinearGradient(x, y, x+s, y+s);
      g.addColorStop(0, '#ffb36b'); g.addColorStop(1, '#ff6b6b');
      roundedRect(x+3, y+3, s-6, s-6, 8, g);
    }

    function roundedRect(x,y,w,h,r, fill) {
      ctx.save(); ctx.beginPath();
      ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath(); ctx.fillStyle = fill; ctx.fill(); ctx.restore();
    }
    function circle(x,y,r, fill) { ctx.save(); ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle = fill; ctx.fill(); ctx.restore(); }

    function draw() {
      const s = cellSize;
      ctx.clearRect(0,0,canvas.width, canvas.height);
      // 背景装饰
      const bg = ctx.createLinearGradient(0,0,0,GRID*s);
      bg.addColorStop(0,'rgba(255,255,255,.02)'); bg.addColorStop(1,'rgba(255,255,255,.0)');
      ctx.fillStyle = bg; ctx.fillRect(0,0,GRID*s, GRID*s);
      drawGrid();
      drawFood();
      drawSnake();
    }

    // 控制逻辑
    function toggleRun() {
      if (dead) return; // 死亡后请重开
      running = !running;
      if (running) { btnToggle.textContent = '暂停'; updateBadge('', false); last = 0; acc = 0; requestAnimationFrame(loop); }
      else { btnToggle.textContent = '继续'; updateBadge('已暂停 · 空格继续'); }
    }
    function restart() { running = false; btnToggle.textContent = '开始'; updateBadge('按 空格 开始'); initGame(); }

    // 初始
    fitCanvas();
    initGame();
  </script>
</body>
</html>